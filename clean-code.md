#### Naming
1. Prefixes before the class names, interface names, type names denoting their type are redundant and it's an old practice. You might have seen interface names like IInterface.
2. Variable names can abbreviated if it's used in a short scope. Variable names used in long scope should have long names that describe the intent of the variable.
3. Public clas names accessible in a long scope should have short names and the private class names used in a short scope should have long names describing the intent of the class. The same goes for public and private methods.
4. Using good names leads to well written pose.

#### Functions
1. Functions should only do one and only one thing.
2. Functions should be 10 lines at max. Ideally 3 or 4 lines.
3. Classes go hide in large functions that use local variables.
4. Functions should be extracted until you drop.
5. Body of if statements can also be another function.

#### Function structure
1. Three arguments at max to a function.
2. Boolean function declares to the world that it does two things. Function should do only one thing.
3. Don't use output arguments.
4. Don't use null as pseudo boolean. Don't pass nulls as arguments. Instead two functions to handle null(no arg function) and non null case.
5. Defensive programming is bad for internal use cases. Public facing APIs keep null checks. Internal code, rely on tech cases to make sure that the nulls are never passed.
6. Step down rule to order functions in a class: Public functions on the top, high level private function, lesser high level private functions, small private functions. Abstract to detailed. Scisors rule, public at top, private below, scissors cut the paper and give top paper to the user. Put public variables followed by private variables at the top of the class. No back references. No function below calls a function above.
7. Temporal coupling: Some functions should be called in the specified, documented order. For example close should be called after open. Functions that modify state introduce temporal coupling. Temporal coupling makes it hard to reason about the program. Functional programming encourage the use of pure functions that don't modify the state, they return always the same output for a given input.
8. Command query pattern: functions that return values don't modify the state and the functions that modify the state don't return the values.
9. Law of demeter: Tell don't ask. Don't ask for the state of the object, instead tell the object to perform an action. Train wreck(chained) pattern calls are bad, it packs so much information in a single line. My take: It also introduces the tight coupling since the high level component is directly depending on the low level component.
10. Switch statements are like a knot, they tighly bind dependencies. This introduces compile time dependencies of the modules. Checked exceptions also introduce compile time dependencies. Think of code as divided into two partitions main partition and the core partition. Main should depend on the core partition and the core should not depend on the main partition. Use switch statements in the main partition. Replace switch statements with base class and derived classes.
11. Avoid complex and multiple early returns from a function. They make it hard to understand code.
12. Function should do only one thing. Either handles exceptions or performs the core logic. Code should not be littered with exception handling logic. It's bad for readability.
13. Remember the stack implementation. Separate anonymous class objects are created for the exceptional cases.
14. Prefer to use the exceptions scoped to the class. Exception name and the context should give most of the information. Pass the message only if it is really necessary.
15. Return null values as output in extreme cases. Prefer to throw an exception instead. Suggested to avoid the functions returning error codes pattern.
16. Checked exceptions are bad. Changes to the overriden method exception in the signature leads to modification of the parent method signature which is an inverse dependency.

### Form
1. Comments
   1. Best comment is the comment not written. Comments and code tends to go out of date. If you write the same info in multiple forms, they tend to diverge and become inconsistent.
   2. "The only reliable documentation of a computer "program is the code itself. "The reason is simple. "Whenever there are multiple representations "of a program, the chance for discrepancy exists. "If the code is in error, artistic flow charts "and detailed comments are to no avail. 
   3. Every comment is an aknowledgement of the failure to express well.
   4. No html in comments as the users can't understand them easily. Comments should only contain the information for the readaer of the code.
   5. Big banner comments are a big no. Since we almost always ignore them.
   6. Nothing can be quite so useful as a well documented public API. If you're using a tool, like Javadoc, or some other automated documentation tool, you should certainly write nice documents for your public APIs. Of course, you should also make sure that your function signatures are self-explanatory. And, keep in mind the best public API documentation is the documentation you don't have to write. 
   7. Comments should describe new information. No redundant information in comments.
   8. Comments also rot because they tend to be non-local. When you change a local line of code in some module in order to fix a bug, or add a new feature, how do you know that there's not some comment somewhere else in the code that you just invalidated?
   9. Code should document itself.
   10. No TODO comments. Use issue tracking systems instead.
   11. No mumbling in comments.
   12. Journal comments. You do have a source code control system, right? Well, then us it.
   13. When you see commented out code, you must delete it. Exponge it from the source code. Don't read it, don't touch it, don't try to understand it.
   14. Rather than using comments to describe what your code does, learn how to use explanatory variables and names. 
2. Dead code: Remove dead code, version control system tracks them anyway.
3. Line length: Remember, never make your readers scroll right. 120 chars at max.
4. Indentation, stick to one style with the team.
5. Space between if/while statements. Group the variables that are related. Variables that aren't related should be spaced. If the functions are four lines long, then you don't need very many of the spaces.
6. As in everything else in software, smaller is better. Keep your file sizes small.
7. Classes
   1. The methods of a class manipulate the variables of that class. The more variables within a class that a method manipulates, the more cohesive that method is. A maximally cohesive method manipulates every variable inside the class. A maximally cohesive class is composed of nothing but maximally cohesive methods. Getters and setters are not very cohesive because they only manipulate a single variable each. The more getters and setters a class has, the less cohesive that class is. So, does that mean that a class should never have getters and setters? Dogmatic rules like that seldom apply in engineering disciplines. I certainly write getters and setters from time to time, but I try to minimize them, because I try to maximize cohesion.
   2.  In those instances where I choose to have a getter, I don't simply expose the variable. I try to abstract out the information being retrieved.
   3.  To be more specific, polymorphism allows us to protect client code, like CarDriver, from changes to the implementation of server code, like Car. It's pretty easy to write a CarDriver that can drive any derivative of Car, without knowing our caring what that derivative is.
   4.  Maybe, you're wondering about classes like Employee, that clearly have methods like getName and getAddress that expose the data within them.
   5. A data structure is kind of the opposite of a class. A data structure has a whole bunch of data variables that are public, and virtually no functions. Do you see the difference here between a class and a data structure? Classes have private variables but public functions. Data structures have public variables and no functions. It might be going a bit too far to say that data structure have no methods. Data structures can have methods. But typically, they're simple things like getters, or setters, or little navigation aids. The methods of a data structure manipulate individual variables. They don't manipulate cohesive groups of variables the way the methods of a class do.
   6. We use classes and objects when it's types that are more likely to be added. We use data structures and Switch statements when it's methods that are more likely to be added. 
   7. For years and years, design experts have been telling us that we should design our applications so that they are separated from our databases by some kind of interface layer. This is very good advice. The last thing we want to see is a bunch of SQL code smeared through our application code.
   8. When getters are absolutely necessary, make sure you hide the implementation of the data by abstracting it. And, use classes to protect yourself from new types, but not new functions. Data structures are bags of data with no cohesive methods. Don't put business rules into data structures. Manipulate them with Switch statements if you must, and use them to protect yourself from new functions, but not new types. Boundaries crisscross our application, separating things that are concrete from things that are abstract. And, all source code dependencies cross those boundaries pointing away from the concrete stuff towards the abstract stuff. Remember that domain objects and database tables are not the same thing, and aren't even strongly related. Separate your domain objects from you database by putting a layer in between them. 

### TDD
1. Code rots due to the fear of change. In order to eliminate the fear of change, we need suite of tests that we trust with our life. TDD provides such test suite. The three rules of TDD are given below.
     1. Write production code only to pass a failing unit test.
     2. Write no more of a unit test than sufficient to fail (compilation failures are failures).
     3. Write no more production code than necessary to pass the one failing unit test.
2. Treat the test cases as if you treat the production code. With TDD, you write tests before the production code. It makes you write test code with care. Test code becomes super useful.
3. Red, green, refactor cycle is followed during TDD i.e write test that fails, make the test pass, refactor the code. 
4. In practice, however, you’ll find yourself sometimes writing tests that pass right off the bat. I refer to these undesired events as​ premature passes​.
5. In practice, you'll make some tests duplicate. Feel free to remove trivial test cases once they are covered by later test cases.
6. TDD is like double entry book keeping in the software development. Software development is a sensitive descipline like accounting. Accountants follow double entry book keeping. The probability of encountering the complimenting errors in the double entry book keeping is low.
7. No need to change the team, it's a personal practice and eventually everyone notices it.
8. Aim for 100% code coverage. It's not possible to achieve 100% coverage.
9. GUI, databases. Don't test the GUI. Don't test the dataabse. Test the data that manipulates the GUI. Use presentation layer to convert business data to the delivery mechanism(GUI, REST) data.
10. Number one, you're not allowed to write any production code until you have first written a failing unit test. Number two, you are not allowed to write more of a unit test than is sufficient to fail, and not compiling is failing. Three, you are not allowed to write more production code than is sufficient to pass the currently failing test.
11. Following these three laws leads to fewer defects, shorter debug times, better and more reliable low-level documentation, code that is highly decoupled and a suite of tests you can trust your life to.
12. Test-driven development does not slow you down, it speeds you up.
13. I made the point that professional developers should expect QA to find nothing.


# Architecture, use cases and design
1. The horrid disease of framework binding
2. When you look at a library, it screams that it's a library. Similarly the temple. The code should not scream that it's a web. It should place the use cases at the center of the design.
3. Web is a delivery mechanism. Application logic should be decoupled with the delivery mechanism, databases, frameworks.
4. When writing the use cases, use the develiry mechanism indipendent terms to describe the use cases.
5. Three types of objects. Entities, interactors, boundaries. Entities are application independent objects. Interactors contain the business logic and use the entities.
6. Architecture is not about choosing frameworks, languages and databases. Architecture looks at the bigger picture as well as the smallest details. Architecture of a building is not the nuts and bolts. An architect who doesn't write code is not an architect in the author's opinion.
7. Keep the frameworks hanging on the side just like the appendix. We should be able to remove it if needed.
8. Good architectures allow you to defer the decisions about tools and frameworks like the UI, like the web server, and even like the dependency injection framework.
9. How do you defer those decisions? You design a structure that decouples you from them, and makes them irrelevant. How do you decouple from tools, frameworks, and databases? You focus your architecture on the use cases, not on the software environment.
10. Separating the use cases from the UI allows the business to measure the cost of each, and then compare that cost to the corresponding business value. And this isn't just limited to the use cases and the UI. All the system components can be isolated in this way. The database, the web server, the various frameworks. And once they're isolated, you can subject them to the same kind of cost versus value analysis.
11. This deferral allows us to keep our options open for as long as possible, and that means we'll be able to change our minds if we need to, perhaps many times during the course of the project, without undue cost. It also creates a strong separation between the system components, which allows the business to compare their cost to their business value, thereby supporting prudent decision making
12. To make matters worse, many developers mistakenly believe that the models are the objects that represent business rules.
13. This is really unfortunate, such systems make the web the central organizing principle, and relegate the business rules to annoying details.
14. His name was Ivar Jacobson. And in this book, he resolved the delivery mechanism problem by providing an elegant architectural solution. That solution was to understand the ways that users interact with the system, in a delivery independent way. In other words, we describe how a user interacts with the system, without using web related words, like link, button, click, or page. Instead, we use words and concepts that don't imply a delivery mechanism.
15. When you look at the architecture of a use case driven system, you see the use cases, not the delivery mechanism. What you see is the intent of the system.
16.  A use case is nothing more, and nothing less, than a formal description of how a user interacts with the system, in order to achieve a specific goal.
17.  Instead, it talks about the data and the commands that go into the system, and the way the system responds. This is important, if we're going to have a delivery independent architecture, we need to start with delivery independent use cases.
18.  Finally, notice that the use case is essentially an algorithm for the interpretation of input data, and the generation of output data.
19.  Now, look again at the algorithm of the primary course of this use case. It mentions other business objects, like Customer and Order. The algorithm defines the use case, and clearly, it has business rules in it. But those business rules don't belong in the Customer and Order business objects. So the question is, where do those business rules belong? What kind of object should we put them in, and where would that use case object fit in our system architecture? As we create more and more use cases, we're going to discover more and more business objects, and more and more use case algorithms. This leaves us with a problem. How do we partition our system in such a way that these use cases become the central organizing principle?
20.  In his book, Jacobson recognized that architectures like this have three fundamental kinds of objects. Business objects, which he called "entities," user interface objects, which he called "boundaries," and use case objects, which he called "controls," but that we will call "interactors" to avoid confusion with Model-View-Controller.
21.  Entity objects are repositories of application independent business rules. The methods on entity objects perform functions that are valid in any of the applications that the entity object can be used in. For example, consider a product object. Such an object would be useful to an order entry system, an order fulfillment system, an inventory management system, or even an online catalog.
22.  More to the point, that product object would have no methods that were specific to any of those applications. Any application specific method would go into one of the interactor objects. Use cases are application specific. Use cases are also implemented by interactor objects. Therefore, interactor objects are also application specific, and that means that any application specific business rule belongs inside of an interactor object.
23.  Boundary objects isolate the use cases from the delivery mechanism, and provide a communications pathway between the two. If you've got an MVC system, or a console system, or a thick client system, all of that delivery stuff is on the far side of the boundary.
24.  The delivery mechanism gathers user data, wraps it up into a nice neat canonical form, ships it through the boundary to the interactors. The interactors then invoke their application specific business rules. They go on to manipulate the entity objects, and their application agnostic business rules. Finally they gather the result data together, wrap it up into a nice, neat canonical form, and ship it back through the boundary to the delivery mechanism. And so the business rules, both the application specific and the application agnostic ones, are strongly decoupled from the delivery mechanism.
25.  So nowadays, the model in a Model-View-Controller framework should draw its data from the collaboration of entities and interactors that implement the use cases. That model may be a single object, but it's not a business object. In fact, those models are seldom more than simple data structures that are passed back and forth across the boundary. Think of it this way, in the web version of Model-View-Controller, the web server receives an HTTP request. It runs this request through its routing mechanism in order to select a controller. The controller then parses through the HTTP request, extracting the request data from it, and putting it into a nice, simple little data structure. And that data structure's really simple. It doesn't have any of the dictionaries or hash maps that are usually associated with web servers and web frameworks. All the web related data tokens and data identifiers and formats have been removed. If you were to look at it in isolation, you wouldn't be able to tell that any part of it came from the web. It's just a pure and simple data structure. That data structure is the model of a request, and it's shipped across the boundary to an interactor. The interactor orchestrates the magic of converting the model of the request into the model of the response. It implements the use case, it coordinates the dance between all the entity objects, it gathers together all the result data, and places it into a pure data structure, the model of the response. 
26. It's composed of two separate sets of interfaces. The first set of interfaces is used by the controllers, but implemented by the interactors. It accepts request model data structures. The second set of interfaces is used by the interactors, but implemented by the presenters. It accepts response model data structures. Those interfaces are the boundary. They belong on the application side, and they are part of the application architecture. The delivery mechanism depends upon them, even implements them.
27. Therefore, you will likely need to provide a boundary layer that separates your database from your entity and interactor objects, probably using the design mechanism we talked about back in episode five, namely, a set of interfaces on the application side, implemented by the database side, with all the dependencies pointing towards the application. So, it's the interactor objects that use the database abstractions on the application side. 
28. An architecture that isolates the delivery mechanism and the database from the application use cases.
29. An architecture that makes those use cases the primary abstraction, and the central organizing principle, what a concept.
30. Nicely organized architectures make you go faster, because everyone knows where everything goes.
31. The point is to make the use cases as agnostic as possible about delivery mechanisms, frameworks, databases, standards bodies, and all that architecturally irrelevant stuff. So we separate the things that matter from the things that don't. This use case lends itself pretty nicely to a little bit of object oriented design.
33. Well, here's a proposal, maybe we should have an employee base class, and three derivatives, one for each of the three employee types. Nice, isn't it? So the next use case we're going to look at is Change Employee, and woah, it's kind of complicated, isn't it? I mean, look at all the things that can change. You can change the employee's name, his address, his payment numbers, the employee type, where you send his paycheck, his union sup, Wait. Did I say type? You can change the employee's type? We better go back and look at that object model again. Yeah, that's not going to work. They're going to want to change hourly employees into salaried employees, and salaried employees into commissioned employees. In most OO languages, it's not easy to change the type of an object once you've constructed it.
34. Had we not carefully considered the Change Employee use case, it's possible we would have missed the payment classification and the schedule abstractions, leaving us to a nasty hack later on. Indeed. Early use case analysis would seem to be essential for understanding the business object model.
35. (code slide) If we continue this use case analysis, as I did in the book, we'll start to see a lovely little abstraction peeking out through the details. Take a look at this pseudocode. This pseudocode tells us the truth. For every employee, if today is the day that employee should be paid, then calculate his pay, and deliver the pay. This is just the fundamental truth. And notice that it is devoid of all details. There's no ugly dependencies. No mention of the web, no mention of frameworks, no mention of hourly, commissioned, salaried, weekly, biweekly, monthly, all of that stuff is gone. There's something beautiful about the fact that this code stands alone, independent, and says the absolute truth.  It is the utter truth. And it's stated in one place, without any obscuring details, or any nagging dependencies.
36. In short, we have not been flummoxed by frameworks, saddled by standards, corralled by communications protocols, detained by databases, or wrangled by web servers.
37. Both of these definitions carry the assumption that architects don't code, that somehow, coding is too low level for someone of the stature of an architect. Well, that's baloney. Architects who don't code quickly become irrelevant. Architects who make high level designs, and never code them, never lie in the beds that they make for the developers. If you are an architect, and you want to be effective in that role, (slurps) then you write code. You should work right alongside the programmers who are lying in the bed that you made for them. Pair program with them, see what their life is really like. Fight alongside the troops in the trenches with them, so you can see what the real architectural problems are. You don't have to code 100% of the time. You don't even have to code 50% of the time. But you do have to code some of the time, and when you code, you should code well.
38. 
